package io.github.apace100.origins.power;

import io.github.apace100.origins.registry.ModEnchantments;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.EquipmentSlot;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.world.Difficulty;

import java.util.Iterator;
import java.util.Map;

public class WaterVulnerabilityPower extends VariableIntPower {

    private static final int damageTickInterval = 20;

    private int outOfWaterTicks;

    public WaterVulnerabilityPower(PowerType<?> type, PlayerEntity player, int startValue, int min, int max) {
        super(type, player, startValue, min, max);
    }

    @Override
    public int getMax() {
        int waterProt = getWaterProtection();
        if(waterProt >= 64) {
            return 20 * 60 * 20;
        }
        return super.getMax() + waterProt * 2 * 20;
    }

    public void inWater() {
        outOfWaterTicks = 0;
        if(getValue() <= 0) {
            setValue(damageTickInterval);
            player.damage(ModDamageSources.HURT_BY_WATER, player.world.getDifficulty() == Difficulty.EASY ? 1.0F : 2.0F);
        } else {
            decrement();
        }
    }

    public void outOfWater() {
        if(outOfWaterTicks >= 20) {
            this.setValue(this.getMax());
        } else {
            outOfWaterTicks++;
        }
    }

    private int getWaterProtection() {
        Map<EquipmentSlot, ItemStack> enchantedItems = ModEnchantments.WATER_PROTECTION.getEquipment(player);
        Iterable<ItemStack> iterable = enchantedItems.values();
        if (iterable == null) {
            return 0;
        } else {
            int i = 0;
            Iterator var4 = iterable.iterator();

            while(var4.hasNext()) {
                ItemStack itemStack = (ItemStack)var4.next();
                i += EnchantmentHelper.getLevel(ModEnchantments.WATER_PROTECTION, itemStack);
            }

            return i * enchantedItems.size();
        }
    }
}
